generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// maybe do all relations to user on "userId" instead of "id" since if you
// have to compare from client side then we will be getting the clerk userId

// ratings model (tied to User)

// TODO: create ChatMessage and Chat models, maybe also a global restaurantConfig or something
// singleton model which could have a field for delayNewOrdersUntil which would be the final 
// DateTime to resume accepting new orders

model MinimumOrderPickupTime {
    id Int @id @default(1)

    value Int @default(0) // will just be 600 for "6:00 PM" for example to make easier to work with on client side
    // ^ 0 will be used to indicate no minimum order time
    // ^ 1159 will be used to indicate to not accept any more orders for the day
}

model FavoriteItem {
    id String @id @default(uuid())

    menuItem   MenuItem @relation(fields: [menuItemId], references: [id])
    menuItemId String
    User       User?    @relation(fields: [userId], references: [userId], onDelete: Cascade)
    userId     String?
}

model MenuCategory {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    name      String
    active    Boolean @default(true)
    listOrder Int     @default(autoincrement())

    menuItems MenuItem[]
}

model MenuItem {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    name             String
    description      String
    imageUrl         String
    price            Float
    ingredientsPrice Float // never expose to the frontend
    available        Boolean @default(true) // whether item is able to be ordered (86'd or not)
    discontinued     Boolean @default(false) // whether item is no longer on the menu
    listOrder        Int     @default(autoincrement())

    MenuCategory   MenuCategory   @relation(fields: [menuCategoryId], references: [id])
    menuCategoryId String
    FavoriteItem   FavoriteItem[]
}

// used to store the order details so before stripe session is created
// so that upon completion the stripe webhook can fetch the order details
// and properly create the Order row in the database
model TransientOrder {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    details Json
    userId  String @unique // not related to User model so that customers can still place order as a guest
}

model Order {
    id        String   @id @default(uuid()) // first 6 digits will be used for any customer-facing order number
    createdAt DateTime @default(now())

    orderStartedAt   DateTime?
    orderCompletedAt DateTime?

    // datetimeToPickup DateTime

    // TODO: do we want to instead just have a datetime for date to be picked up?
    // that includes the time as well? Think about tradeoffs and what exactly would
    // need to happen conversion wise.
    // ^ although if they really are the raw datetimes then would just have to
    // set the minOrderTime to the actual datetime instead of the number value
    // and then it would just be datetimeToPickup >= minOrderDatetime
    // so then in cron it would reset to the new day's 00:00 datetime of that day!

    status            String @default("received") // "received", "inProgress", "completed" (maybe "cancelled" too?)
    firstName         String
    lastName          String
    email             String
    phoneNumber       String
    details           Json // This is the entire order, including all items, prices, etc. that appears on the ticket
    prevRewardsPoints Int
    rewardsPoints     Int
    prevRewardsRank   Int
    rewardsRank       Int

    stripeSessionId String @unique // used for tracking the order in Stripe

    // could have the userDescription field on here to be populated by chatGPT response to if
    // the user is noteworthy. Prob want to delay this until order is first created though, just a setTimeout()
    // in prisma .create method?
    User   User?   @relation(fields: [userId], references: [userId])
    userId String?
}

model Reward {
    id        Int      @id @default(autoincrement())
    createdAt DateTime @default(now())

    type           String // either "discount" or "promotionMeal"
    value          Int?
    expirationDate DateTime? // not sure if this is worth it, but could simplify frontend logic a bit
    User           User?     @relation(fields: [userId], references: [userId], onDelete: Cascade)
    userId         String?
}

model User {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    userId              String   @unique // retrieved from Clerk
    firstName           String
    lastName            String
    email               String   @unique
    phoneNumber         String   @unique
    birthday            DateTime
    dietaryRestrictions String

    allowsNotificationEmails Boolean @default(true)
    allowsPromotionalEmails  Boolean @default(true)

    rewardsRank   Int @default(1) // I think we would just use the string name of each rank?
    rewardsPoints Int @default(50) // TODO: most likely change this later

    showRewardsNotification Boolean @default(false)

    currentOrder Json?

    rewards       Reward[]
    recentOrders  Order[]
    favoriteItems FavoriteItem[]
}
