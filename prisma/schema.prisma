generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// TODO: very very carefully prune through which models/relations need onDelete: Cascade or some
// variation

// TODO: create ChatMessage and Chat models, maybe also a global restaurantConfig or something
// singleton model which could have a field for delayNewOrdersUntil which would be the final 
// DateTime to resume accepting new orders

model Review {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    message           String
    allowedToBePublic Boolean

    order   Order  @relation(fields: [orderId], references: [id])
    orderId String

    user   User   @relation(fields: [userId], references: [userId])
    userId String
}

model MinimumOrderPickupTime {
    id Int @id @default(1)

    value DateTime @default(now()) // will get reset to midnight of current day every day by a cron job
}

model FavoriteItem {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    menuItem   MenuItem @relation(fields: [menuItemId], references: [id])
    menuItemId String
    user       User     @relation(fields: [userId], references: [userId], onDelete: Cascade)
    userId     String
}

model MenuCategory {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    name      String
    active    Boolean @default(true)
    listOrder Int     @default(autoincrement())

    menuItems        MenuItem[]
    activeDiscount   Discount?  @relation(fields: [activeDiscountId], references: [id])
    activeDiscountId String?
}

model MenuItem {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    name             String
    description      String
    imageUrl         String
    price            Float
    ingredientsPrice Float // never expose to the frontend, could even just have it only on w/e backend stats calculation function(s)
    available        Boolean @default(true) // whether item is able to be ordered (86'd or not)
    discontinued     Boolean @default(false) // whether item is no longer on the menu
    listOrder        Int     @default(autoincrement())

    menuCategory     MenuCategory @relation(fields: [menuCategoryId], references: [id])
    menuCategoryId   String
    activeDiscount   Discount?    @relation(fields: [activeDiscountId], references: [id])
    activeDiscountId String?

    chefsChoice Boolean @default(false)

    favoriteItem          FavoriteItem[]
    customizationCategory CustomizationCategory[]
    orderItem             OrderItem[]
}

model CustomizationCategory {
    id          String @id @default(uuid())
    name        String // e.g., "Size", "Toppings"
    description String // e.g., "Select your drink size"

    defaultChoiceId String

    menuItem               MenuItem[]
    customizationChoice    CustomizationChoice[]
    orderItemCustomization OrderItemCustomization[]
}

model CustomizationChoice {
    id              String @id @default(uuid())
    name            String // e.g., "Small", "Medium", "Large" for Size
    description     String // e.g., "12 oz", "16 oz", "20 oz" for Size, or description of side dish if applicable
    priceAdjustment Float // Additional cost for this choice, can be negative

    customizationCategory   CustomizationCategory    @relation(fields: [customizationCategoryId], references: [id])
    customizationCategoryId String
    orderItemCustomization  OrderItemCustomization[]
}

// used to store the order details so before stripe session is created
// so that upon completion the stripe webhook can fetch the order details
// and properly create the Order row in the database
model TransientOrder {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    details Json
    userId  String @unique // not related to User model so that customers can still place order as a guest
}

model OrderItem {
    id                         String  @id @default(uuid())
    name                       String
    specialInstructions        String
    includeDietaryRestrictions Boolean
    quantity                   Int
    price                      Float

    order      Order    @relation(fields: [orderId], references: [id])
    orderId    String
    menuItem   MenuItem @relation(fields: [menuItemId], references: [id])
    menuItemId String

    // only need to store discount relation here so that when looking at tracking/recent orders
    // you can see why a price for an item would be different across orders.
    discount   Discount? @relation(fields: [discountId], references: [id])
    discountId String?

    customizations OrderItemCustomization[]
}

model OrderItemCustomization {
    id String @id @default(uuid())

    orderItem               OrderItem             @relation(fields: [orderItemId], references: [id])
    orderItemId             String
    customizationCategory   CustomizationCategory @relation(fields: [customizationCategoryId], references: [id])
    customizationCategoryId String
    customizationChoice     CustomizationChoice   @relation(fields: [customizationChoiceId], references: [id])
    customizationChoiceId   String
}

model Order {
    id        String   @id @default(uuid()) // first 6 digits will be used for any customer-facing order number
    createdAt DateTime @default(now())

    orderStartedAt   DateTime?
    orderCompletedAt DateTime?
    datetimeToPickup DateTime

    // TODO: remove status, just infer from orderStartedAt and orderCompletedAt
    status                    String  @default("received") // "received", "inProgress", "completed" (maybe "cancelled" too?)
    firstName                 String
    lastName                  String
    email                     String
    phoneNumber               String
    includeNapkinsAndUtensils Boolean @default(false)
    dietaryRestrictions       String? // gets queried for and added on /websocket if user has dietary restrictions and has 1+ item in order that has dietary restrictions boolean as true

    orderItems OrderItem[]
    discount   Discount?   @relation(fields: [discountId], references: [id])
    discountId String?

    prevRewardsPoints Int
    rewardsPoints     Int

    stripeSessionId String @unique // used for tracking the order in Stripe

    // could have the userDescription field on here to be populated by chatGPT response to if
    // the user is noteworthy. Prob want to delay this until order is first created though, just a setTimeout()
    // in prisma .create method?
    user   User?   @relation(fields: [userId], references: [userId])
    userId String?

    reviews Review[] // these are just the direct reviews on the order, so that the dashboard can show the user's order
    // alongside their feedback. This isn't to be confused with the to be made "MenuItemReview" model
}

model Discount {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    name           String
    description    String // maybe show this on user's rewards page w/ like "Enjoy a {item1} or {item2} 15% off this weekend!"
    // or something more personalized like that
    expirationDate DateTime
    active         Boolean  @default(true)

    menuCategory MenuCategory[]
    menuItem     MenuItem[]
    orderItem    OrderItem[]

    Order Order[]

    user   User?   @relation(fields: [userId], references: [userId], onDelete: Cascade)
    userId String?

    @@index([id, userId]) // TODO: is this the right way to do this? and do you want to index the userId field on User model?
}

model User {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now())

    userId              String   @unique // retrieved from Clerk
    firstName           String
    lastName            String
    email               String   @unique
    phoneNumber         String   @unique
    birthday            DateTime
    dietaryRestrictions String

    allowsEmailReceipts       Boolean @default(true)
    allowsOrderCompleteEmails Boolean @default(true)
    allowsPromotionalEmails   Boolean @default(true)

    rewardsPoints Int @default(50) // TODO: most likely change this later

    showRewardsNotification         Boolean @default(false) // from racking up points/birthday reward
    showRewardsDiscountNotification Boolean @default(false) // just from any active discounts for members

    currentOrder Json? // this still has to be json because we aren't doing the whole "transient"-esque normalizaton of this,
    // it has to work for unregistered users anyway so this is fine. Just need to validate heavily on initialization
    // on the client side

    recentOrders  Order[]
    favoriteItems FavoriteItem[]
    discounts     Discount[]
    reviews       Review[]

    @@index([userId])
}
